{"filter":false,"title":"homCoreyP1.cpp","tooltip":"/homCoreyP1.cpp","undoManager":{"mark":100,"position":100,"stack":[[{"start":{"row":90,"column":18},"end":{"row":90,"column":19},"action":"insert","lines":["t"],"id":1}],[{"start":{"row":90,"column":19},"end":{"row":90,"column":20},"action":"insert","lines":["a"],"id":2}],[{"start":{"row":90,"column":20},"end":{"row":90,"column":21},"action":"insert","lines":["t"],"id":3}],[{"start":{"row":90,"column":21},"end":{"row":90,"column":22},"action":"insert","lines":["e"],"id":4}],[{"start":{"row":90,"column":22},"end":{"row":90,"column":23},"action":"insert","lines":[" "],"id":5}],[{"start":{"row":90,"column":23},"end":{"row":90,"column":24},"action":"insert","lines":["="],"id":6}],[{"start":{"row":90,"column":24},"end":{"row":90,"column":25},"action":"insert","lines":["="],"id":7}],[{"start":{"row":90,"column":25},"end":{"row":90,"column":26},"action":"insert","lines":[" "],"id":8}],[{"start":{"row":90,"column":26},"end":{"row":90,"column":27},"action":"insert","lines":["2"],"id":9}],[{"start":{"row":90,"column":28},"end":{"row":91,"column":0},"action":"insert","lines":["",""],"id":10},{"start":{"row":91,"column":0},"end":{"row":91,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":91,"column":8},"end":{"row":91,"column":9},"action":"insert","lines":["{"],"id":11}],[{"start":{"row":91,"column":9},"end":{"row":93,"column":9},"action":"insert","lines":["","            ","        }"],"id":12}],[{"start":{"row":92,"column":12},"end":{"row":92,"column":13},"action":"insert","lines":["c"],"id":13}],[{"start":{"row":92,"column":12},"end":{"row":92,"column":13},"action":"remove","lines":["c"],"id":14}],[{"start":{"row":92,"column":12},"end":{"row":92,"column":13},"action":"insert","lines":["t"],"id":15}],[{"start":{"row":92,"column":13},"end":{"row":92,"column":14},"action":"insert","lines":["a"],"id":16}],[{"start":{"row":92,"column":14},"end":{"row":92,"column":15},"action":"insert","lines":["b"],"id":17}],[{"start":{"row":92,"column":15},"end":{"row":92,"column":16},"action":"insert","lines":["l"],"id":18}],[{"start":{"row":92,"column":16},"end":{"row":92,"column":17},"action":"insert","lines":["e"],"id":19}],[{"start":{"row":92,"column":17},"end":{"row":92,"column":19},"action":"insert","lines":["[]"],"id":20}],[{"start":{"row":92,"column":18},"end":{"row":92,"column":19},"action":"insert","lines":["i"],"id":21}],[{"start":{"row":92,"column":19},"end":{"row":92,"column":20},"action":"insert","lines":["n"],"id":22}],[{"start":{"row":92,"column":20},"end":{"row":92,"column":21},"action":"insert","lines":["d"],"id":23}],[{"start":{"row":92,"column":21},"end":{"row":92,"column":22},"action":"insert","lines":["e"],"id":24}],[{"start":{"row":92,"column":22},"end":{"row":92,"column":23},"action":"insert","lines":["x"],"id":25}],[{"start":{"row":92,"column":24},"end":{"row":92,"column":25},"action":"insert","lines":["-"],"id":26}],[{"start":{"row":92,"column":25},"end":{"row":92,"column":26},"action":"insert","lines":["-"],"id":27}],[{"start":{"row":92,"column":26},"end":{"row":92,"column":27},"action":"insert","lines":[";"],"id":28}],[{"start":{"row":92,"column":27},"end":{"row":93,"column":0},"action":"insert","lines":["",""],"id":29},{"start":{"row":93,"column":0},"end":{"row":93,"column":12},"action":"insert","lines":["            "]}],[{"start":{"row":93,"column":12},"end":{"row":93,"column":13},"action":"insert","lines":["r"],"id":30}],[{"start":{"row":93,"column":13},"end":{"row":93,"column":14},"action":"insert","lines":["e"],"id":31}],[{"start":{"row":93,"column":14},"end":{"row":93,"column":15},"action":"insert","lines":["t"],"id":32}],[{"start":{"row":93,"column":15},"end":{"row":93,"column":16},"action":"insert","lines":["u"],"id":33}],[{"start":{"row":93,"column":16},"end":{"row":93,"column":17},"action":"insert","lines":["r"],"id":34}],[{"start":{"row":93,"column":17},"end":{"row":93,"column":18},"action":"insert","lines":["n"],"id":35}],[{"start":{"row":93,"column":18},"end":{"row":93,"column":19},"action":"insert","lines":[" "],"id":36}],[{"start":{"row":93,"column":19},"end":{"row":93,"column":20},"action":"insert","lines":["c"],"id":37}],[{"start":{"row":93,"column":20},"end":{"row":93,"column":21},"action":"insert","lines":["o"],"id":38}],[{"start":{"row":93,"column":21},"end":{"row":93,"column":22},"action":"insert","lines":["r"],"id":39}],[{"start":{"row":93,"column":22},"end":{"row":93,"column":23},"action":"insert","lines":["r"],"id":40}],[{"start":{"row":93,"column":23},"end":{"row":93,"column":24},"action":"insert","lines":["e"],"id":41}],[{"start":{"row":93,"column":24},"end":{"row":93,"column":25},"action":"insert","lines":["c"],"id":42}],[{"start":{"row":93,"column":25},"end":{"row":93,"column":26},"action":"insert","lines":["t"],"id":43}],[{"start":{"row":93,"column":26},"end":{"row":93,"column":27},"action":"insert","lines":[";"],"id":44}],[{"start":{"row":94,"column":9},"end":{"row":95,"column":0},"action":"insert","lines":["",""],"id":45},{"start":{"row":95,"column":0},"end":{"row":95,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":95,"column":8},"end":{"row":95,"column":9},"action":"insert","lines":["e"],"id":46}],[{"start":{"row":95,"column":9},"end":{"row":95,"column":10},"action":"insert","lines":["l"],"id":47}],[{"start":{"row":95,"column":10},"end":{"row":95,"column":11},"action":"insert","lines":["s"],"id":48}],[{"start":{"row":95,"column":11},"end":{"row":95,"column":12},"action":"insert","lines":["e"],"id":49}],[{"start":{"row":95,"column":12},"end":{"row":95,"column":13},"action":"insert","lines":[" "],"id":50}],[{"start":{"row":95,"column":13},"end":{"row":95,"column":14},"action":"insert","lines":["i"],"id":51}],[{"start":{"row":95,"column":14},"end":{"row":95,"column":15},"action":"insert","lines":["f"],"id":52}],[{"start":{"row":95,"column":15},"end":{"row":95,"column":16},"action":"insert","lines":[" "],"id":53}],[{"start":{"row":95,"column":16},"end":{"row":95,"column":18},"action":"insert","lines":["()"],"id":54}],[{"start":{"row":95,"column":17},"end":{"row":95,"column":18},"action":"insert","lines":["s"],"id":55}],[{"start":{"row":95,"column":18},"end":{"row":95,"column":19},"action":"insert","lines":["t"],"id":56}],[{"start":{"row":95,"column":19},"end":{"row":95,"column":20},"action":"insert","lines":["a"],"id":57}],[{"start":{"row":95,"column":20},"end":{"row":95,"column":21},"action":"insert","lines":["t"],"id":58}],[{"start":{"row":95,"column":21},"end":{"row":95,"column":22},"action":"insert","lines":["e"],"id":59}],[{"start":{"row":95,"column":22},"end":{"row":95,"column":23},"action":"insert","lines":[" "],"id":60}],[{"start":{"row":95,"column":23},"end":{"row":95,"column":24},"action":"insert","lines":["="],"id":61}],[{"start":{"row":95,"column":24},"end":{"row":95,"column":25},"action":"insert","lines":["="],"id":62}],[{"start":{"row":95,"column":25},"end":{"row":95,"column":26},"action":"insert","lines":[" "],"id":63}],[{"start":{"row":95,"column":26},"end":{"row":95,"column":27},"action":"insert","lines":["3"],"id":64}],[{"start":{"row":95,"column":28},"end":{"row":96,"column":0},"action":"insert","lines":["",""],"id":65},{"start":{"row":96,"column":0},"end":{"row":96,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":96,"column":8},"end":{"row":96,"column":9},"action":"insert","lines":["{"],"id":66}],[{"start":{"row":96,"column":9},"end":{"row":98,"column":9},"action":"insert","lines":["","            ","        }"],"id":67}],[{"start":{"row":97,"column":12},"end":{"row":97,"column":13},"action":"insert","lines":["t"],"id":68}],[{"start":{"row":97,"column":13},"end":{"row":97,"column":14},"action":"insert","lines":["a"],"id":69}],[{"start":{"row":97,"column":14},"end":{"row":97,"column":15},"action":"insert","lines":["b"],"id":70}],[{"start":{"row":97,"column":15},"end":{"row":97,"column":16},"action":"insert","lines":["l"],"id":71}],[{"start":{"row":97,"column":16},"end":{"row":97,"column":17},"action":"insert","lines":["e"],"id":72}],[{"start":{"row":97,"column":17},"end":{"row":97,"column":19},"action":"insert","lines":["[]"],"id":73}],[{"start":{"row":97,"column":18},"end":{"row":97,"column":19},"action":"insert","lines":["i"],"id":74}],[{"start":{"row":97,"column":19},"end":{"row":97,"column":20},"action":"insert","lines":["n"],"id":75}],[{"start":{"row":97,"column":20},"end":{"row":97,"column":21},"action":"insert","lines":["d"],"id":76}],[{"start":{"row":97,"column":21},"end":{"row":97,"column":22},"action":"insert","lines":["e"],"id":77}],[{"start":{"row":97,"column":22},"end":{"row":97,"column":23},"action":"insert","lines":["x"],"id":78}],[{"start":{"row":97,"column":24},"end":{"row":97,"column":25},"action":"insert","lines":["-"],"id":79}],[{"start":{"row":97,"column":25},"end":{"row":97,"column":26},"action":"insert","lines":["-"],"id":80}],[{"start":{"row":97,"column":26},"end":{"row":97,"column":27},"action":"insert","lines":[";"],"id":81}],[{"start":{"row":97,"column":27},"end":{"row":98,"column":0},"action":"insert","lines":["",""],"id":82},{"start":{"row":98,"column":0},"end":{"row":98,"column":12},"action":"insert","lines":["            "]}],[{"start":{"row":98,"column":12},"end":{"row":98,"column":13},"action":"insert","lines":["r"],"id":83}],[{"start":{"row":98,"column":13},"end":{"row":98,"column":14},"action":"insert","lines":["e"],"id":84}],[{"start":{"row":98,"column":14},"end":{"row":98,"column":15},"action":"insert","lines":["t"],"id":85}],[{"start":{"row":98,"column":15},"end":{"row":98,"column":16},"action":"insert","lines":["u"],"id":86}],[{"start":{"row":98,"column":16},"end":{"row":98,"column":17},"action":"insert","lines":["r"],"id":87}],[{"start":{"row":98,"column":17},"end":{"row":98,"column":18},"action":"insert","lines":["n"],"id":88}],[{"start":{"row":98,"column":18},"end":{"row":98,"column":19},"action":"insert","lines":[" "],"id":89}],[{"start":{"row":98,"column":19},"end":{"row":98,"column":20},"action":"insert","lines":["b"],"id":90}],[{"start":{"row":98,"column":19},"end":{"row":98,"column":20},"action":"remove","lines":["b"],"id":91}],[{"start":{"row":98,"column":19},"end":{"row":98,"column":20},"action":"insert","lines":["c"],"id":92}],[{"start":{"row":98,"column":20},"end":{"row":98,"column":21},"action":"insert","lines":["o"],"id":93}],[{"start":{"row":98,"column":21},"end":{"row":98,"column":22},"action":"insert","lines":["r"],"id":94}],[{"start":{"row":98,"column":22},"end":{"row":98,"column":23},"action":"insert","lines":["r"],"id":95}],[{"start":{"row":98,"column":23},"end":{"row":98,"column":24},"action":"insert","lines":["e"],"id":96}],[{"start":{"row":98,"column":24},"end":{"row":98,"column":25},"action":"insert","lines":["c"],"id":97}],[{"start":{"row":98,"column":25},"end":{"row":98,"column":26},"action":"insert","lines":["t"],"id":98}],[{"start":{"row":98,"column":26},"end":{"row":98,"column":27},"action":"insert","lines":[";"],"id":99}],[{"start":{"row":0,"column":0},"end":{"row":266,"column":0},"action":"remove","lines":["#include <iostream>","#include <string>","#include <fstream>","using namespace std;","","//Assume that the initial state of all prediction counters is T","//0 means predicted incorrectly","//1 means predicted correctly","int predictorSingleBit(int * table, int index, char branch)","{","  int correct = 0;","  //if the branch is true","  if (branch == 'T')","  {","    //if >= 1 in the index which we initialized, then that means we predicted correctly","    if (table[index] >= 1)","    {","      correct = 1;","    }","    //if we didn't predict true, we have to increment this index for future","    else","    {","      table[index] += 1;","    }","  }","  else","  {","    //if not taken, and we have it predicted to be not taken, we are correct","    if (table[index] < 1)","    {","      correct = 1;","    }","    //if not taken but predicted to be taken, we decrement this index for the future","    else","    {","      table[index] -= 1;","    }","  }","  return correct;","}","int predictor2Bit(int *table, int index, char branch)","{","    int correct = 0;","    int state = table[index] % 4;","    if (branch == 'T') {","      if (state == 0)","      {","        table[index]++;","        return correct;","      }","      else if (state == 1)","      {","          table[index]++;","          return correct;","      }","      else if (state == 2)","      {","          table[index]++;","          correct = 1;","          return correct;","      }","      else if (state == 3)","      {","          correct = 1;","          return correct;","      }","        //   switch(state){","        //     case 0:","        //     case 1:","        //         table[index]++;","        //         break;","        //     case 2:","        //         table[index]++;","        //     case 3:","        //         correct = 1;","        //         break;","        // }","    }","    else","    {","        if (state == 0)","        {","            correct = 1;","            return correct;","        }","        else if (state == 1)","        {","            correct = 1;","            return correct;","        }","        else if (state == 2)","        {","            table[index]--;","            return correct;","        }","        else if (state == 3)","        {","            table[index]--;","            return correct;","        }","        // switch (state) {","        //     case 0:","        //         correct = 1;","        //         break;","        //     case 1:","        //         correct = 1;","        //     case 2:","        //     case 3:","        //         table[index]--;","        //         break;","        // }","    }","    return correct;","}","int main ( int argc, char *argv[] )","{","  if ( argc != 3 ) ","    cout<<\"usage: \"<< argv[0] <<\" <file input> \" << \"<file output>\\n\";","  else {","    ifstream input( argv[1] );","    if ( !input.is_open() )","      cout<<\"Could not open file\\n\";","    //file is open now.","    else ","    {","      //Open the output file","      ofstream output (argv[2]);","      ","      //Bimodal predictors need a table of size 16, 32, 128, 256, 512, 1024, 2048","      //Note there is no size 64","      int *tableS16 = new int[16];","      int *tableS32 = new int[32];","      int *tableS128 = new int[128];","      int *tableS256 = new int[256];","      int *tableS512 = new int[512];","      int *tableS1024 = new int[1024];","      int *tableS2048 = new int[2048];","      int *tableD16 = new int[16];","      int *tableD32 = new int[32];","      int *tableD128 = new int[128];","      int *tableD256 = new int[256];","      int *tableD512 = new int[512];","      int *tableD1024 = new int[1024];","      int *tableD2048 = new int[2048];","      ","      //Prediction table for bimodal table","      for (int i = 0; i < 16; i++)","      {","        tableS16[i] = 1;","        tableD16[i] = 3;","      }","      for (int i = 0; i < 32; i++)","      {","        tableS32[i] = 1;","        tableD32[i] = 3;","      }","      for (int i = 0; i < 128; i++)","      {","        tableS128[i] = 1;","        tableD128[i] = 3;","      }","      for (int i = 0; i < 256; i++)","      {","        tableS256[i] = 1;","        tableD256[i] = 3;","      }","      for (int i = 0; i < 512; i++)","      {","        tableS512[i] = 1;","        tableD512[i] = 3;","      }","      for (int i = 0; i < 1024; i++)","      {","        tableS1024[i] = 1;","        tableD1024[i] = 3;","      }","      for (int i = 0; i < 2048; i++)","      {","        tableS2048[i] = 1;","        tableD2048[i] = 3;","      }","      //Counters","      int alwaysTaken = 0;","      int alwaysNot = 0;","      int GHR = 0;","      int single16 = 0, single32 = 0, ","      single128 = 0, single256 = 0, ","      single512 = 0, single1024 = 0, single2048 = 0;","      int two16 = 0, two32 = 0, ","      two128 = 0, two256 = 0, ","      two512 = 0, two1024 = 0, two2048 = 0;","      //Read the file","      while (!input.eof())","      {","        long long address;","        //we can convert the address to hex using std::hex","        input >> hex >> address;","        if (input.fail()) break;","","        char branch;","        input >> branch;","        if (input.fail()) break;","","        input.ignore(256, '\\n');","        ","        //GHR T = 1","        //Part 1 and 2 are covered here","        if (branch == 'T')","        {","          alwaysTaken++;","          GHR++;","        }","        else","        {","          alwaysNot++;","        }","        ","        //Part 3","        //Small memory that is indexed by the lower portion of the address of the branch instruction","        //Contains one or more bits indicating whether the branch was recently taken or not","        single16 += predictorSingleBit(tableS16, address % 16, branch);","        single32 += predictorSingleBit(tableS32, address % 32, branch);","        single128 += predictorSingleBit(tableS128, address % 128, branch);","        single256 += predictorSingleBit(tableS256, address % 256, branch);","        single512 += predictorSingleBit(tableS512, address % 512, branch);","        single1024 += predictorSingleBit(tableS1024, address % 1024, branch);","        single2048 += predictorSingleBit(tableS2048, address % 2048, branch);","        ","        two16 += predictor2Bit(tableD16, address % 16, branch);","        two32 += predictor2Bit(tableD32, address % 32, branch);","        two128 += predictor2Bit(tableD128, address % 128, branch);","        two256 += predictor2Bit(tableD256, address % 256, branch);","        two512 += predictor2Bit(tableD512, address % 512, branch);","        two1024 += predictor2Bit(tableD1024, address % 1024, branch);","        two2048 += predictor2Bit(tableD2048, address % 2048, branch);","      }","      cout << \"alwaysTaken: \" << alwaysTaken << endl;","      cout << \"alwaysNot: \" << alwaysNot << endl;","      cout << \"Total: \" << alwaysTaken + alwaysNot << endl;","      cout << \"single16: \" << single16 << endl;","      cout << \"single32: \" << single32 << endl;","      cout << \"single128: \" << single128 << endl;","      cout << \"single256: \" << single256 << endl;","      cout << \"single512: \" << single512 << endl;","      cout << \"single1024: \" << single1024 << endl;","      cout << \"single2048: \" << single2048 << endl;","      cout << \"two16: \" << two16 << endl;","      cout << \"two32: \" << two32 << endl;","      cout << \"two128: \" << two128 << endl;","      cout << \"two256: \" << two256 << endl;","      cout << \"two512: \" << two512 << endl;","      cout << \"two1024: \" << two1024 << endl;","      cout << \"two2048: \" << two2048 << endl;","      output.close();","      //Remember to delete the tables","      delete [] tableS16;","      delete [] tableS32;","      delete [] tableS128;","      delete [] tableS256;","      delete [] tableS512;","      delete [] tableS1024;","      delete [] tableS2048;","    }","    input.close();","  }","}",""],"id":100},{"start":{"row":0,"column":0},"end":{"row":241,"column":0},"action":"insert","lines":["#include <iostream>","#include <string>","#include <fstream>","using namespace std;","","//Assume that the initial state of all prediction counters is T","//0 means predicted incorrectly","//1 means predicted correctly","int predictorSingleBit(int * table, int index, char branch)","{","  int correct = 0;","  //if the branch is true","  if (branch == 'T')","  {","    //if >= 1 in the index which we initialized, then that means we predicted correctly","    if (table[index] >= 1)","    {","      correct = 1;","    }","    //if we didn't predict true, we have to increment this index for future","    else","    {","      table[index] += 1;","    }","  }","  else","  {","    //if not taken, and we have it predicted to be not taken, we are correct","    if (table[index] < 1)","    {","      correct = 1;","    }","    //if not taken but predicted to be taken, we decrement this index for the future","    else","    {","      table[index] -= 1;","    }","  }","  return correct;","}","","//assume TT","//we can index % 4 to get the state since there are 4 possible states, 00, 01, 10, 11 (TT to NTT etc)","//extension of 1bit predictor","int predictor2Bit(int *table, int index, char branch)","{","    int correct = 0;","    int state = table[index] % 4;","    if (branch == 'T') {","      if (state == 0)","      {","        table[index]++;","      }","      else if (state == 1)","      {","          table[index]++;","      }","      else if (state == 2)","      {","          table[index]++;","          correct = 1;","      }","      else if (state == 3)","      {","          correct = 1;","      }","    }","    else","    {","        if (state == 0)","        {","            correct = 1;","        }","        else if (state == 1)","        {","            correct = 1;","            table[index]--;","        }","        else if (state == 2)","        {","            table[index]--;","        }","        else if (state == 3)","        {","            table[index]--;","        }","    }","    return correct;","}","int main ( int argc, char *argv[] )","{","  if ( argc != 3 ) ","    cout<<\"usage: \"<< argv[0] <<\" <file input> \" << \"<file output>\\n\";","  else {","    ifstream input( argv[1] );","    if ( !input.is_open() )","      cout<<\"Could not open file\\n\";","    //file is open now.","    else ","    {","      //Open the output file","      ofstream output (argv[2]);","      ","      //Bimodal predictors need a table of size 16, 32, 128, 256, 512, 1024, 2048","      //Note there is no size 64","      int *tableS16 = new int[16];","      int *tableS32 = new int[32];","      int *tableS128 = new int[128];","      int *tableS256 = new int[256];","      int *tableS512 = new int[512];","      int *tableS1024 = new int[1024];","      int *tableS2048 = new int[2048];","      int *tableD16 = new int[16];","      int *tableD32 = new int[32];","      int *tableD128 = new int[128];","      int *tableD256 = new int[256];","      int *tableD512 = new int[512];","      int *tableD1024 = new int[1024];","      int *tableD2048 = new int[2048];","      ","      //Prediction table for bimodal table","      for (int i = 0; i < 16; i++)","      {","        tableS16[i] = 1;","        tableD16[i] = 3;","      }","      for (int i = 0; i < 32; i++)","      {","        tableS32[i] = 1;","        tableD32[i] = 3;","      }","      for (int i = 0; i < 128; i++)","      {","        tableS128[i] = 1;","        tableD128[i] = 3;","      }","      for (int i = 0; i < 256; i++)","      {","        tableS256[i] = 1;","        tableD256[i] = 3;","      }","      for (int i = 0; i < 512; i++)","      {","        tableS512[i] = 1;","        tableD512[i] = 3;","      }","      for (int i = 0; i < 1024; i++)","      {","        tableS1024[i] = 1;","        tableD1024[i] = 3;","      }","      for (int i = 0; i < 2048; i++)","      {","        tableS2048[i] = 1;","        tableD2048[i] = 3;","      }","      //Counters","      int alwaysTaken = 0;","      int alwaysNot = 0;","      int GHR = 0;","      int single16 = 0, single32 = 0, ","      single128 = 0, single256 = 0, ","      single512 = 0, single1024 = 0, single2048 = 0;","      int two16 = 0, two32 = 0, ","      two128 = 0, two256 = 0, ","      two512 = 0, two1024 = 0, two2048 = 0;","      //Read the file","      while (!input.eof())","      {","        long long address;","        //we can convert the address to hex using std::hex","        input >> hex >> address;","        if (input.fail()) break;","","        char branch;","        input >> branch;","        if (input.fail()) break;","","        input.ignore(256, '\\n');","        ","        //GHR T = 1","        //Part 1 and 2 are covered here","        if (branch == 'T')","        {","          alwaysTaken++;","          GHR++;","        }","        else","        {","          alwaysNot++;","        }","        ","        //Part 3","        //Small memory that is indexed by the lower portion of the address of the branch instruction","        //Contains one or more bits indicating whether the branch was recently taken or not","        single16 += predictorSingleBit(tableS16, address % 16, branch);","        single32 += predictorSingleBit(tableS32, address % 32, branch);","        single128 += predictorSingleBit(tableS128, address % 128, branch);","        single256 += predictorSingleBit(tableS256, address % 256, branch);","        single512 += predictorSingleBit(tableS512, address % 512, branch);","        single1024 += predictorSingleBit(tableS1024, address % 1024, branch);","        single2048 += predictorSingleBit(tableS2048, address % 2048, branch);","        ","        two16 += predictor2Bit(tableD16, address % 16, branch);","        two32 += predictor2Bit(tableD32, address % 32, branch);","        two128 += predictor2Bit(tableD128, address % 128, branch);","        two256 += predictor2Bit(tableD256, address % 256, branch);","        two512 += predictor2Bit(tableD512, address % 512, branch);","        two1024 += predictor2Bit(tableD1024, address % 1024, branch);","        two2048 += predictor2Bit(tableD2048, address % 2048, branch);","      }","      cout << \"alwaysTaken: \" << alwaysTaken << endl;","      cout << \"alwaysNot: \" << alwaysNot << endl;","      cout << \"Total: \" << alwaysTaken + alwaysNot << endl;","      cout << \"single16: \" << single16 << endl;","      cout << \"single32: \" << single32 << endl;","      cout << \"single128: \" << single128 << endl;","      cout << \"single256: \" << single256 << endl;","      cout << \"single512: \" << single512 << endl;","      cout << \"single1024: \" << single1024 << endl;","      cout << \"single2048: \" << single2048 << endl;","      cout << \"two16: \" << two16 << endl;","      cout << \"two32: \" << two32 << endl;","      cout << \"two128: \" << two128 << endl;","      cout << \"two256: \" << two256 << endl;","      cout << \"two512: \" << two512 << endl;","      cout << \"two1024: \" << two1024 << endl;","      cout << \"two2048: \" << two2048 << endl;","      output.close();","      //Remember to delete the tables","      delete [] tableS16;","      delete [] tableS32;","      delete [] tableS128;","      delete [] tableS256;","      delete [] tableS512;","      delete [] tableS1024;","      delete [] tableS2048;","    }","    input.close();","  }","}",""]}],[{"start":{"row":0,"column":0},"end":{"row":241,"column":0},"action":"remove","lines":["#include <iostream>","#include <string>","#include <fstream>","using namespace std;","","//Assume that the initial state of all prediction counters is T","//0 means predicted incorrectly","//1 means predicted correctly","int predictorSingleBit(int * table, int index, char branch)","{","  int correct = 0;","  //if the branch is true","  if (branch == 'T')","  {","    //if >= 1 in the index which we initialized, then that means we predicted correctly","    if (table[index] >= 1)","    {","      correct = 1;","    }","    //if we didn't predict true, we have to increment this index for future","    else","    {","      table[index] += 1;","    }","  }","  else","  {","    //if not taken, and we have it predicted to be not taken, we are correct","    if (table[index] < 1)","    {","      correct = 1;","    }","    //if not taken but predicted to be taken, we decrement this index for the future","    else","    {","      table[index] -= 1;","    }","  }","  return correct;","}","","//assume TT","//we can index % 4 to get the state since there are 4 possible states, 00, 01, 10, 11 (TT to NTT etc)","//extension of 1bit predictor","int predictor2Bit(int *table, int index, char branch)","{","    int correct = 0;","    int state = table[index] % 4;","    if (branch == 'T') {","      if (state == 0)","      {","        table[index]++;","      }","      else if (state == 1)","      {","          table[index]++;","      }","      else if (state == 2)","      {","          table[index]++;","          correct = 1;","      }","      else if (state == 3)","      {","          correct = 1;","      }","    }","    else","    {","        if (state == 0)","        {","            correct = 1;","        }","        else if (state == 1)","        {","            correct = 1;","            table[index]--;","        }","        else if (state == 2)","        {","            table[index]--;","        }","        else if (state == 3)","        {","            table[index]--;","        }","    }","    return correct;","}","int main ( int argc, char *argv[] )","{","  if ( argc != 3 ) ","    cout<<\"usage: \"<< argv[0] <<\" <file input> \" << \"<file output>\\n\";","  else {","    ifstream input( argv[1] );","    if ( !input.is_open() )","      cout<<\"Could not open file\\n\";","    //file is open now.","    else ","    {","      //Open the output file","      ofstream output (argv[2]);","      ","      //Bimodal predictors need a table of size 16, 32, 128, 256, 512, 1024, 2048","      //Note there is no size 64","      int *tableS16 = new int[16];","      int *tableS32 = new int[32];","      int *tableS128 = new int[128];","      int *tableS256 = new int[256];","      int *tableS512 = new int[512];","      int *tableS1024 = new int[1024];","      int *tableS2048 = new int[2048];","      int *tableD16 = new int[16];","      int *tableD32 = new int[32];","      int *tableD128 = new int[128];","      int *tableD256 = new int[256];","      int *tableD512 = new int[512];","      int *tableD1024 = new int[1024];","      int *tableD2048 = new int[2048];","      ","      //Prediction table for bimodal table","      for (int i = 0; i < 16; i++)","      {","        tableS16[i] = 1;","        tableD16[i] = 3;","      }","      for (int i = 0; i < 32; i++)","      {","        tableS32[i] = 1;","        tableD32[i] = 3;","      }","      for (int i = 0; i < 128; i++)","      {","        tableS128[i] = 1;","        tableD128[i] = 3;","      }","      for (int i = 0; i < 256; i++)","      {","        tableS256[i] = 1;","        tableD256[i] = 3;","      }","      for (int i = 0; i < 512; i++)","      {","        tableS512[i] = 1;","        tableD512[i] = 3;","      }","      for (int i = 0; i < 1024; i++)","      {","        tableS1024[i] = 1;","        tableD1024[i] = 3;","      }","      for (int i = 0; i < 2048; i++)","      {","        tableS2048[i] = 1;","        tableD2048[i] = 3;","      }","      //Counters","      int alwaysTaken = 0;","      int alwaysNot = 0;","      int GHR = 0;","      int single16 = 0, single32 = 0, ","      single128 = 0, single256 = 0, ","      single512 = 0, single1024 = 0, single2048 = 0;","      int two16 = 0, two32 = 0, ","      two128 = 0, two256 = 0, ","      two512 = 0, two1024 = 0, two2048 = 0;","      //Read the file","      while (!input.eof())","      {","        long long address;","        //we can convert the address to hex using std::hex","        input >> hex >> address;","        if (input.fail()) break;","","        char branch;","        input >> branch;","        if (input.fail()) break;","","        input.ignore(256, '\\n');","        ","        //GHR T = 1","        //Part 1 and 2 are covered here","        if (branch == 'T')","        {","          alwaysTaken++;","          GHR++;","        }","        else","        {","          alwaysNot++;","        }","        ","        //Part 3","        //Small memory that is indexed by the lower portion of the address of the branch instruction","        //Contains one or more bits indicating whether the branch was recently taken or not","        single16 += predictorSingleBit(tableS16, address % 16, branch);","        single32 += predictorSingleBit(tableS32, address % 32, branch);","        single128 += predictorSingleBit(tableS128, address % 128, branch);","        single256 += predictorSingleBit(tableS256, address % 256, branch);","        single512 += predictorSingleBit(tableS512, address % 512, branch);","        single1024 += predictorSingleBit(tableS1024, address % 1024, branch);","        single2048 += predictorSingleBit(tableS2048, address % 2048, branch);","        ","        two16 += predictor2Bit(tableD16, address % 16, branch);","        two32 += predictor2Bit(tableD32, address % 32, branch);","        two128 += predictor2Bit(tableD128, address % 128, branch);","        two256 += predictor2Bit(tableD256, address % 256, branch);","        two512 += predictor2Bit(tableD512, address % 512, branch);","        two1024 += predictor2Bit(tableD1024, address % 1024, branch);","        two2048 += predictor2Bit(tableD2048, address % 2048, branch);","      }","      cout << \"alwaysTaken: \" << alwaysTaken << endl;","      cout << \"alwaysNot: \" << alwaysNot << endl;","      cout << \"Total: \" << alwaysTaken + alwaysNot << endl;","      cout << \"single16: \" << single16 << endl;","      cout << \"single32: \" << single32 << endl;","      cout << \"single128: \" << single128 << endl;","      cout << \"single256: \" << single256 << endl;","      cout << \"single512: \" << single512 << endl;","      cout << \"single1024: \" << single1024 << endl;","      cout << \"single2048: \" << single2048 << endl;","      cout << \"two16: \" << two16 << endl;","      cout << \"two32: \" << two32 << endl;","      cout << \"two128: \" << two128 << endl;","      cout << \"two256: \" << two256 << endl;","      cout << \"two512: \" << two512 << endl;","      cout << \"two1024: \" << two1024 << endl;","      cout << \"two2048: \" << two2048 << endl;","      output.close();","      //Remember to delete the tables","      delete [] tableS16;","      delete [] tableS32;","      delete [] tableS128;","      delete [] tableS256;","      delete [] tableS512;","      delete [] tableS1024;","      delete [] tableS2048;","    }","    input.close();","  }","}",""],"id":101},{"start":{"row":0,"column":0},"end":{"row":250,"column":0},"action":"insert","lines":["#include <iostream>","#include <string>","#include <fstream>","using namespace std;","","//Assume that the initial state of all prediction counters is T","//0 means predicted incorrectly","//1 means predicted correctly","int predictorSingleBit(int * table, int index, char branch)","{","  int correct = 0;","  //if the branch is true","  if (branch == 'T')","  {","    //if >= 1 in the index which we initialized, then that means we predicted correctly","    if (table[index] >= 1)","    {","      correct = 1;","    }","    //if we didn't predict true, we have to increment this index for future","    else","    {","      table[index] += 1;","    }","  }","  else","  {","    //if not taken, and we have it predicted to be not taken, we are correct","    if (table[index] < 1)","    {","      correct = 1;","    }","    //if not taken but predicted to be taken, we decrement this index for the future","    else","    {","      table[index] -= 1;","    }","  }","  return correct;","}","","//assume TT","//we can index % 4 to get the state since there ","int predictor2Bit(int *table, int index, char branch)","{","    int correct = 0;","    int state = table[index] % 4;","    if (branch == 'T') {","      //NT or weakly NT just increment index for next time","      if (state == 0)","      {","        table[index]++;","      }","      else if (state == 1)","      {","          table[index]++;","      }","      //if TT or weak T we are 1","      else if (state == 2)","      {","          table[index]++;","          correct = 1;","      }","      else if (state == 3)","      {","          correct = 1;","      }","    }","    else","    {","      //other way around for NT","        if (state == 0)","        {","            correct = 1;","        }","        else if (state == 1)","        {","            correct = 1;","            table[index]--;","        }","        else if (state == 2)","        {","            table[index]--;","        }","        else if (state == 3)","        {","            table[index]--;","        }","    }","    return correct;","}","int main ( int argc, char *argv[] )","{","  if ( argc != 3 ) ","    cout<<\"usage: \"<< argv[0] <<\" <file input> \" << \"<file output>\\n\";","  else {","    ifstream input( argv[1] );","    if ( !input.is_open() )","      cout<<\"Could not open file\\n\";","    //file is open now.","    else ","    {","      //Open the output file","      ofstream output (argv[2]);","      ","      //Bimodal predictors need a table of size 16, 32, 128, 256, 512, 1024, 2048","      //Note there is no size 64","      int *tableS16 = new int[16];","      int *tableS32 = new int[32];","      int *tableS128 = new int[128];","      int *tableS256 = new int[256];","      int *tableS512 = new int[512];","      int *tableS1024 = new int[1024];","      int *tableS2048 = new int[2048];","      int *tableD16 = new int[16];","      int *tableD32 = new int[32];","      int *tableD128 = new int[128];","      int *tableD256 = new int[256];","      int *tableD512 = new int[512];","      int *tableD1024 = new int[1024];","      int *tableD2048 = new int[2048];","      ","      //Prediction table for bimodal table","      for (int i = 0; i < 16; i++)","      {","        tableS16[i] = 1;","        tableD16[i] = 3;","      }","      for (int i = 0; i < 32; i++)","      {","        tableS32[i] = 1;","        tableD32[i] = 3;","      }","      for (int i = 0; i < 128; i++)","      {","        tableS128[i] = 1;","        tableD128[i] = 3;","      }","      for (int i = 0; i < 256; i++)","      {","        tableS256[i] = 1;","        tableD256[i] = 3;","      }","      for (int i = 0; i < 512; i++)","      {","        tableS512[i] = 1;","        tableD512[i] = 3;","      }","      for (int i = 0; i < 1024; i++)","      {","        tableS1024[i] = 1;","        tableD1024[i] = 3;","      }","      for (int i = 0; i < 2048; i++)","      {","        tableS2048[i] = 1;","        tableD2048[i] = 3;","      }","      //Counters","      int alwaysTaken = 0;","      int alwaysNot = 0;","      int GHR = 0;","      int single16 = 0, single32 = 0, ","      single128 = 0, single256 = 0, ","      single512 = 0, single1024 = 0, single2048 = 0;","      int two16 = 0, two32 = 0, ","      two128 = 0, two256 = 0, ","      two512 = 0, two1024 = 0, two2048 = 0;","      //Read the file","      while (!input.eof())","      {","        long long address;","        //we can convert the address to hex using std::hex","        input >> hex >> address;","        if (input.fail()) break;","","        char branch;","        input >> branch;","        if (input.fail()) break;","","        input.ignore(256, '\\n');","        ","        //GHR T = 1","        //Part 1 and 2 are covered here","        if (branch == 'T')","        {","          alwaysTaken++;","          GHR++;","        }","        else","        {","          alwaysNot++;","        }","        ","        //Part 3","        //Small memory that is indexed by the lower portion of the address of the branch instruction","        //Contains one or more bits indicating whether the branch was recently taken or not","        single16 += predictorSingleBit(tableS16, address % 16, branch);","        single32 += predictorSingleBit(tableS32, address % 32, branch);","        single128 += predictorSingleBit(tableS128, address % 128, branch);","        single256 += predictorSingleBit(tableS256, address % 256, branch);","        single512 += predictorSingleBit(tableS512, address % 512, branch);","        single1024 += predictorSingleBit(tableS1024, address % 1024, branch);","        single2048 += predictorSingleBit(tableS2048, address % 2048, branch);","        ","        two16 += predictor2Bit(tableD16, address % 16, branch);","        two32 += predictor2Bit(tableD32, address % 32, branch);","        two128 += predictor2Bit(tableD128, address % 128, branch);","        two256 += predictor2Bit(tableD256, address % 256, branch);","        two512 += predictor2Bit(tableD512, address % 512, branch);","        two1024 += predictor2Bit(tableD1024, address % 1024, branch);","        two2048 += predictor2Bit(tableD2048, address % 2048, branch);","      }","      cout << \"alwaysTaken: \" << alwaysTaken << endl;","      cout << \"alwaysNot: \" << alwaysNot << endl;","      cout << \"Total: \" << alwaysTaken + alwaysNot << endl;","      cout << \"single16: \" << single16 << endl;","      cout << \"single32: \" << single32 << endl;","      cout << \"single128: \" << single128 << endl;","      cout << \"single256: \" << single256 << endl;","      cout << \"single512: \" << single512 << endl;","      cout << \"single1024: \" << single1024 << endl;","      cout << \"single2048: \" << single2048 << endl;","      cout << \"two16: \" << two16 << endl;","      cout << \"two32: \" << two32 << endl;","      cout << \"two128: \" << two128 << endl;","      cout << \"two256: \" << two256 << endl;","      cout << \"two512: \" << two512 << endl;","      cout << \"two1024: \" << two1024 << endl;","      cout << \"two2048: \" << two2048 << endl;","      output.close();","      //Remember to delete the tables","      delete [] tableS16;","      delete [] tableS32;","      delete [] tableS128;","      delete [] tableS256;","      delete [] tableS512;","      delete [] tableS1024;","      delete [] tableS2048;","      delete [] tableD16;","      delete [] tableD32;","      delete [] tableD128;","      delete [] tableD256;","      delete [] tableD512;","      delete [] tableS1024;","      delete [] tableS2048;","    }","    input.close();","  }","}",""]}]]},"ace":{"folds":[],"scrolltop":2941,"scrollleft":0,"selection":{"start":{"row":250,"column":0},"end":{"row":250,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":195,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1426777492000,"hash":"30dba166eb03ded798e57d4664ba077f16e29a30"}